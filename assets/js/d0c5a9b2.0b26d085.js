"use strict";(self.webpackChunkwrittings_website=self.webpackChunkwrittings_website||[]).push([[7214],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(a),h=s,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function h(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,o=new Array(i);o[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},1749:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return h}});var n=a(7462),s=a(3366),i=(a(7294),a(3905)),o=["components"],r={slug:"the-anatomy-of-an-inspector",title:"How to light up the dark forest - a walkthrough of building a cryptopunk MEV inspector",authors:["robert"],tags:["flashbots"],image:"/img/transparency-january-1.png",hide_table_of_contents:!1},l=void 0,c={permalink:"/writings/the-anatomy-of-an-inspector",source:"@site/writings/2021-12-15-the-anatomy-of-an-inspector.mdx",title:"How to light up the dark forest - a walkthrough of building a cryptopunk MEV inspector",description:"A step-by-step walkthrough of how to add a new MEV inspector using a recently added cryptopunk snipers inspector as an example.",date:"2021-12-15T00:00:00.000Z",formattedDate:"December 15, 2021",tags:[{label:"flashbots",permalink:"/writings/tags/flashbots"}],readingTime:10.96,truncated:!0,authors:[{name:"Robert Miller",title:"Product @Flashbots",url:"https://twitter.com/bertcmiller",imageURL:"https://pbs.twimg.com/profile_images/1336354612064911360/qGVMxddJ_400x400.jpg",key:"robert"}],nextItem:{title:"Why Building the Most Profitable Block is Important",permalink:"/writings/on-the-most-profitable-block"}},p={authorsImageUrls:[void 0]},u=[{value:"Punk snipers and mev-inspect-py",id:"punk-snipers-and-mev-inspect-py",children:[]},{value:"Building with mev-inspect-py",id:"building-with-mev-inspect-py",children:[{value:"Add the cryptopunk ABI",id:"add-the-cryptopunk-abi",children:[]},{value:"Creating Classification and Protocol entries",id:"creating-classification-and-protocol-entries",children:[]},{value:"Create a punk classifier spec",id:"create-a-punk-classifier-spec",children:[]},{value:"Build schemas with the data we want",id:"build-schemas-with-the-data-we-want",children:[]},{value:"Parse the traces into our new schemas",id:"parse-the-traces-into-our-new-schemas",children:[]},{value:"Add database models and crud functions",id:"add-database-models-and-crud-functions",children:[]},{value:"Add Alembic files for database migrations",id:"add-alembic-files-for-database-migrations",children:[]},{value:"Putting it all together",id:"putting-it-all-together",children:[]}]}],d={toc:u};function h(e){var t=e.components,a=(0,s.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A step-by-step walkthrough of how to add a new MEV inspector using a recently added cryptopunk snipers inspector as an example."),(0,i.kt)("h2",{id:"punk-snipers-and-mev-inspect-py"},"Punk snipers and mev-inspect-py"),(0,i.kt)("p",null,"Last month I was pinged on Twitter about a novel form of MEV involving cryptopunks, one of the first and most valuable NFTs. Cryptopunks, or punks, were designed with their own native marketplace in the contract. You can list your punk, bid on other punks, and accept bids from the cryptopunk smart contract itself."),(0,i.kt)("p",null,"However, the design of this marketplace left open an area for frontrunning bots! When a punk owner accepted an offer to sell their punk they were actually accepting the highest existing offer on the market. If someone offered to buy a punk at a very low price and the punk owner accepted that offer, then MEV bots would race in front of the punk owner\u2019s acceptance with an offer that was just barely higher than the original low priced offer. As a result the MEV bot\u2019s offer would be the highest when the owner\u2019s acceptance was executed, and the MEV bot would receive the punk at a great price."),(0,i.kt)("p",null,"By doing so these sniper bots were able to systematically buy cryptopunks at low prices at the expense of the users who had originally placed low bids! The punk community was upset because the buyers who worked to find and attempted buy punks at low prices weren\u2019t being rewarded \u2013 bots were."),(0,i.kt)("p",null,"With this in mind I turned to mev-inspect (\u201cInspect\u201d) to try to shine a bright light on what was going on in the underbelly of the punk market. Inspect is Flashbots\u2019 open source tool to inspect historical Ethereum blocks for MEV extraction, and the data pipeline underlying MEV-explore. Inspect attempts to classify MEV extraction by strategy and to surface relevant data for analysis. For example, it can spot arbitrage between a number of top DEXes as well as liquidations. It is the perfect tool to analyze new MEV strategies."),(0,i.kt)("p",null,"Inspect had gone through a few iterations since I had last contributed. It was now 10x more professional with 10x the features because of the great work by my colleagues Taarush, Gui, and Luke. As a team we felt that the codebase was ready for more contributions, and I was excited to try to do that by adding a new inspector for this punks use case."),(0,i.kt)("p",null,"The cryptopunk snipe inspector is now live and in production. This blog post documents the process of writing a new inspector and uses the cryptopunk snipe inspector as a reference. I hope it serves as a motivation and guide for others to contribute to Inspect. A follow on blog post will focus on the data surrounding cryptopunk sniping MEV."),(0,i.kt)("h2",{id:"building-with-mev-inspect-py"},"Building with mev-inspect-py"),(0,i.kt)("p",null,"At a high level inspect works by getting all of the traces for a transaction, classifying traces, building schemas, inferring MEV strategies, and finally posting data to a database. At the end of this process inspect will have populated a database with structured data about the mev strategies it found."),(0,i.kt)("p",null,"To add a new MEV strategy, the cryptopunk sniping, to Inspect I took the following steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Add the cryptopunk ABI to our list of ABIs ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/abis/cryptopunks/cryptopunks.json"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"List classifications for the actions we want under the trace schema ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/schemas/traces.py#L34-L35"},"(link)")," as well as a cryptopunk entry in the protocols ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/schemas/traces.py#L49"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"Create a punk classifier spec ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/classifiers/specs/cryptopunks.py#L17"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"Build schemas with the data we want ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/schemas/punk_snipe.py"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"Parse the traces into our new punk schemas ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/punks.py"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"Add database models ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/models/punks.py"},"(link)")," and crud functions ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/crud/punks.py"},"(link)")),(0,i.kt)("li",{parentName:"ul"},"Add Alembic files for database migrations ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/flashbots/mev-inspect-py/blob/main/alembic/versions/52d75a7e0533_add_punk_bid_acceptances.py"},"(link)"))),(0,i.kt)("p",null,"Here I implemented a new strategy inspector, which required all 7 steps. ",(0,i.kt)("strong",{parentName:"p"},"But if you\u2019re adding a new protocol (e.g. a DEX) to an existing inspector (e.g. arbitrage), then only the first 3 steps are necessary because steps 4 to 7 have already been completed. New specs will fit into existing schemas, parsing scripts, and database integrations.")),(0,i.kt)("p",null,"Regardless, let\u2019s look at each of these 7 steps in detail. This process is only loosely linear and looks more intimidating than it is. Some steps are performed in parallel and you may revisit some steps as you design your objects."),(0,i.kt)("h3",{id:"add-the-cryptopunk-abi"},"Add the cryptopunk ABI"),(0,i.kt)("p",null,"To identify a contract and its functions Inspect needs its ABI. With a quick Google search I found the ",(0,i.kt)("a",{parentName:"p",href:"https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb#code"},"CryptoPunks contract address on Etherscan")," and grabbed the abi by clicking \u201ccontract,\u201d scrolling down, and copy/pasting the ABI into a new file. That file was named ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/abis/cryptopunks/cryptopunks.json"},"\u201ccryptopunks.json"),"\u201d and placed in a \u201c",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect/abis/cryptopunks"},"cryptopunks"),"\u201d folder inside the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect/abis"},"ABI folder"),"."),(0,i.kt)("h3",{id:"creating-classification-and-protocol-entries"},"Creating Classification and Protocol entries"),(0,i.kt)("p",null,"(This blog post assumes some knowledge of traces. Please review ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/@theimperialduke/ethereum-traces-not-transactions-3f0533d26aa"},"this blog post")," if you need an intro.)"),(0,i.kt)("p",null,"For a given trace Inspect will attempt to classify it by checking:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What address is this trace interacting with?"),(0,i.kt)("li",{parentName:"ul"},"Does that address have an ABI that Inspect knows about?"),(0,i.kt)("li",{parentName:"ul"},"Is the trace calling a function we care about?")),(0,i.kt)("p",null,"Thus far we have only given Inspect an ABI, but soon we\u2019ll write a specification that tells Inspect what addresses and functions to look for. Whenever it finds that address and function combination in a trace it will classify that trace with a label that you give it. This step is about creating those labels."),(0,i.kt)("p",null,"Given we are classifying traces, we add a classification to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/schemas/traces.py#L34-L35"},"traces.py schema"),". This is as easy as listing a short description of the things we want to classify, in this case, punk bids (punk_bid) and punk bid acceptances (punk_accept_bid)."),(0,i.kt)("p",null,"We also add an entry under \u201cProtocol\u201d for the protocol we\u2019re working on if it doesn\u2019t already exist. Again, we add \u201c",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/schemas/traces.py#L49"},"cryptopunks"),"\u201d to the list of protocols."),(0,i.kt)("h3",{id:"create-a-punk-classifier-spec"},"Create a punk classifier spec"),(0,i.kt)("p",null,"A classifier spec builds on the Classification and Protocol entries we just made by telling Inspect what to look for in classifying traces. For the cryptopunk sniper it looked like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from mev_inspect.schemas.traces import Protocol, Classification\nfrom mev_inspect.schemas.classifiers import (\n    ClassifierSpec,\n    Classifier,\n)\nclass PunkBidAcceptanceClassifier(Classifier):\n    @staticmethod\n    def get_classification() -> Classification:\n        return Classification.punk_accept_bid\nclass PunkBidClassifier(Classifier):\n    @staticmethod\n    def get_classification() -> Classification:\n        return Classification.punk_bid\nCRYPTO_PUNKS_SPEC = ClassifierSpec(\n    abi_name="cryptopunks",\n    protocol=Protocol.cryptopunks,\n    valid_contract_addresses=["0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB"],\n    classifiers={\n        "enterBidForPunk(uint256)": PunkBidClassifier,\n        "acceptBidForPunk(uint256,uint256)": PunkBidAcceptanceClassifier,\n    },\n)\nCRYPTOPUNKS_CLASSIFIER_SPECS = [CRYPTO_PUNKS_SPEC]\n')),(0,i.kt)("p",null,"Let\u2019s work through this. First, we create classes for the classifiers of the action that we are interested in. In our case we want to classify punk bids and acceptances, so we create PunkBidAcceptanceClassifier and PunkBidClassifier. "),(0,i.kt)("p",null,"Inspect asks you to be specific about how these classifiers are used. The reason for this is that we want to be able to identify some types of actions across many protocols, but not all protocols are designed in the same way. For example, the function to swap assets is different across many DEXes, so in order to build a single \u201cswap\u201d classification, we need to tell Inspect what to do for each protocol you want to classify swaps on."),(0,i.kt)("p",null,"For one-off protocols, like my punk inspector, you can copy the template that I used and replace the punk-specific parts. But if you are adding support for a protocol to classify an action that isn\u2019t standardized across the ecosystem I\u2019d suggest looking at how Swaps are implemented across a few DEXes."),(0,i.kt)("p",null,"Below these standardized functions are the spec itself. The spec has 4 parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"abi_name"),": the name of the abi entered earlier. Must match exactly the filename you specified."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"protocol"),": the protocol specified in the previous step."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"valid_contract_addresses"),": any contract addresses that you want to look for. Note that this can be omitted in the case that you don\u2019t want to limit a classifier to a set of addresses."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"classifiers"),": a list of functions that you want to look for along with their classifications. For example, we want to look for punk bids, so we create an entry for the \u201cPunkBidClassifier\u201d for the function \u201centerBidForPunk(uint256).\u201d Note that classifiers work through the usage of ",(0,i.kt)("a",{parentName:"li",href:"https://solidity-by-example.org/function-selector/"},"function selectors"),", so you must specify the function name and its types with no spaces.")),(0,i.kt)("p",null,"Lastly, you must add the classifier spec to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/classifiers/specs/__init__.py"},"init.py")," file to make it visible to Inspect. At this point, Inspect will start to classify traces associated with your protocol \ud83c\udf89! "),(0,i.kt)("p",null,"After running inspect on blocks that contain the MEV you are looking for you can ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py#exploring"},"view the output of Inspect by pulling up the database")," and querying the \u201cclassified_traces\u201d table for your ABI. If you are adding support for a new protocol (e.g. a dex) to an existing inspector (e.g. arbs) then your work would be finished at this stage!"),(0,i.kt)("h3",{id:"build-schemas-with-the-data-we-want"},"Build schemas with the data we want"),(0,i.kt)("p",null,"Inspect works by building structured objects we call schemas. Each schema is stored in a separate file in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect/schemas"},"schemas folder")," and is built to store data about some object. They look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class PunkBid(BaseModel):\n    block_number: int\n    transaction_hash: str\n    trace_address: List[int]\n    from_address: str\n    punk_index: int\n    price: int\n")),(0,i.kt)("p",null,"You will need to make a schema for each new object you\u2019d like to create. In my case, I created three: punk bids, punk bid acceptances, and punk snipes. In making a schema think about the information that you and others will want to see."),(0,i.kt)("h3",{id:"parse-the-traces-into-our-new-schemas"},"Parse the traces into our new schemas"),(0,i.kt)("p",null,"With traces being classified for the actions we want we can start to query for our classifications and write the logic of our strategy inspector. The way to do this is simple. As an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'if trace.classification == Classification.punk_bid:\n            punk_bid = PunkBid(\n                transaction_hash=trace.transaction_hash,\n                block_number=trace.block_number,\n                trace_address=trace.trace_address,\n                from_address=trace.from_address,\n                punk_index=trace.inputs["punkIndex"],\n                price=trace.value,\n            )\nreturn punk_bid\n')),(0,i.kt)("p",null,"For every new strategy inspector, we create a file in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect"},"mev_inspect folder")," and reference it in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/inspect_block.py"},"inspect_block.py"),", the heart of Inspect. The function you are calling should take in a list of classified traces and return a schema."),(0,i.kt)("p",null,"In the case of punk bids and acceptances, we need little logic to build our schemas. However, the use case of identifying punk snipes requires some logic and a list of both bids and acceptances. We first get bids and acceptances, then use these as inputs to a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/9ffa9d2df9474924391058427d9feddde504ac02/mev_inspect/punks.py#L29-L55"},"function that checks for snipes"),", and returns a list of snipes if any existed."),(0,i.kt)("p",null,"At this point I\u2019ll add a few prints in my code to make and turn a test run to make sure everything is working as intended. You can run a test with the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"./mev inspect [BLOCK_NUMBER]\n")),(0,i.kt)("h3",{id:"add-database-models-and-crud-functions"},"Add database models and crud functions"),(0,i.kt)("p",null,"Now almost all of the logic of your inspector has been completed. What remains is to post the data you\u2019ve generated to databases for easy querying and viewing. To do this we need to create models of what our database entry should look like, and crud functions to write/delete from the database."),(0,i.kt)("p",null,"Database models specify the data you want to be stored and what data types each entry should be. Here\u2019s what the punk snipe entry looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class PunkSnipeModel(Base):\n    __tablename__ = "punk_snipes"\n    block_number = Column(Numeric, nullable=False)\n    transaction_hash = Column(String, primary_key=True)\n    trace_address = Column(ARRAY(Integer), primary_key=True)\n    from_address = Column(String, nullable=False)\n    punk_index = Column(Integer, nullable=False)\n    min_acceptance_price = Column(Numeric, nullable=False)\n    acceptance_price = Column(Numeric, nullable=False)\n')),(0,i.kt)("p",null,"You should create a unique file and store it in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect/models"},"models folder"),".\nCrud functions are stored in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/tree/main/mev_inspect/crud"},"the crud folder"),". These use our schemas and database models to write and delete from the Inspect database. I suggest you read the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-inspect-py/blob/main/mev_inspect/crud/punks.py"},"punk crud")," as an example and use it as a template to create your own by replacing the schema and models."),(0,i.kt)("h3",{id:"add-alembic-files-for-database-migrations"},"Add Alembic files for database migrations"),(0,i.kt)("p",null,"Alembic is a lightweight database migration tool. We use it to manage different revisions to the inspect database. Given you\u2019re adding a new inspector you\u2019ll need to make changes to the databases."),(0,i.kt)("p",null,"To spin up a new alembic revision file use the following command:\n",(0,i.kt)("inlineCode",{parentName:"p"},"./mev exec alembic revision \u2014autogenerate -m \u201c{message}\u201d"),"\nThen copy it out of your kubernetes pod into your local machine with:\n",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl cp pod:dir/file local_dir/file"),"\nNow edit this file and add the features of the database that you want. This should closely resemble the model that you created in the last step. The alembic file for the punk snipe database entry is a nice example. Finally, upgrade your database with the new migration with:\n",(0,i.kt)("inlineCode",{parentName:"p"},"./mev exec alembic upgrade head")),(0,i.kt)("h3",{id:"putting-it-all-together"},"Putting it all together"),(0,i.kt)("p",null,"Now you are ready to inspect a block and query the database for results. First we run Inspect over a block:\n",(0,i.kt)("inlineCode",{parentName:"p"},"./mev inspect [BLOCK_NUMBER]"),"\nNow we connect to the local postgres database:\n",(0,i.kt)("inlineCode",{parentName:"p"},"./mev db"),"\nYou should see ",(0,i.kt)("inlineCode",{parentName:"p"},"mev_inspect=#"),". In my case I wanted to check out my new punk tables, so I ran\n",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT COUNT(*) FROM punk_snipes;"),"\nWhich returned 1! That means Inspect is successfully finding punk snipes. "),(0,i.kt)("p",null,"Congratulations! You\u2019ve learned about the different moving parts involved in creating a new MEV inspector. I hope you\u2019ll give writing one yourself a shot, and don\u2019t be afraid to jump in the Flashbots Discord to ask questions in #mev-inspect. We have a list of current and desired classifiers on the Inspect repo if you suggestions for where to start. Come illuminate the dark forest with us, anon!"),(0,i.kt)("p",null,"Thank you to Taarush, Chris, Gui, Luke, and Alex for reviewing this article."))}h.isMDXComponent=!0}}]);